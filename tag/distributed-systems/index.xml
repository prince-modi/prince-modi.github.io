<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Distributed Systems | Prince Modi</title>
    <link>http://localhost:1313/tag/distributed-systems/</link>
      <atom:link href="http://localhost:1313/tag/distributed-systems/index.xml" rel="self" type="application/rss+xml" />
    <description>Distributed Systems</description>
    <generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><lastBuildDate>Tue, 05 Mar 2024 00:00:00 +0000</lastBuildDate>
    <image>
      <url>http://localhost:1313/media/icon_hua5d2116872382d6405c4fb215e02fa8e_2300_512x512_fill_lanczos_center_3.png</url>
      <title>Distributed Systems</title>
      <link>http://localhost:1313/tag/distributed-systems/</link>
    </image>
    
    <item>
      <title>Exploring the Power of Google Spanner for Distributed Transaction Processing</title>
      <link>http://localhost:1313/post/google-spanner/</link>
      <pubDate>Tue, 05 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/post/google-spanner/</guid>
      <description>&lt;p&gt;This article is my understanding of distributed transactions and various aspects of &lt;strong&gt;Spanner&lt;/strong&gt;, such as its structure, how it handles transactions like Read-Write and Read-Only Transactions, and the &lt;strong&gt;TrueTime API&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;distributed-transactions&#34;&gt;Distributed Transactions&lt;/h2&gt;
&lt;p&gt;Transactions package multiple operations on data records to ensure they execute as a single unit, even in the event of failure. These guarantees are often referred to as &lt;strong&gt;ACID&lt;/strong&gt; properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Atomic&lt;/strong&gt;: All-or-nothing&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consistent&lt;/strong&gt;: The system must remain in a valid state before and after&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Isolated&lt;/strong&gt;: Each transaction appears to run alone&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Durable&lt;/strong&gt;: Changes persist despite failures&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;need-for-distributed-transactions&#34;&gt;Need for Distributed Transactions&lt;/h2&gt;
&lt;p&gt;Large databases often contain millions of records and are &lt;strong&gt;sharded&lt;/strong&gt; across machines (e.g., one shard contains rows A–N, another O–Z) to improve performance. When a transaction spans multiple shards, we need &lt;strong&gt;concurrency control&lt;/strong&gt; and &lt;strong&gt;commit protocols&lt;/strong&gt; to preserve ACID guarantees.&lt;/p&gt;
&lt;p&gt;Spanner addresses this by using &lt;strong&gt;Two-Phase Locking (2PL)&lt;/strong&gt; and &lt;strong&gt;Two-Phase Commit (2PC)&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;spanner-architecture&#34;&gt;Spanner Architecture&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;Spanner deployment&lt;/strong&gt; is called a &lt;strong&gt;universe&lt;/strong&gt;. It is composed of multiple &lt;strong&gt;zones&lt;/strong&gt;, each with:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;zonemaster&lt;/strong&gt; that assigns data to spanservers&lt;/li&gt;
&lt;li&gt;Between 100 and several thousand &lt;strong&gt;spanservers&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each spanserver manages &lt;strong&gt;100–1000 tablets&lt;/strong&gt;, which are sharded partitions of tables based on primary keys.&lt;/p&gt;
&lt;p&gt;To support replication, Spanner:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implements a &lt;strong&gt;Paxos state machine&lt;/strong&gt; per tablet&lt;/li&gt;
&lt;li&gt;Replicates tablets across spanservers using &lt;strong&gt;Paxos groups&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Handles concurrency control via a &lt;strong&gt;lock table&lt;/strong&gt; at the Paxos leader&lt;/li&gt;
&lt;li&gt;Uses a &lt;strong&gt;transaction manager&lt;/strong&gt; to coordinate multi-tablet transactions&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;truetime-api&#34;&gt;TrueTime API&lt;/h2&gt;
&lt;p&gt;Spanner relies on the &lt;strong&gt;TrueTime API&lt;/strong&gt; to support external consistency and concurrency control.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TrueTime returns an interval: &lt;code&gt;TTinterval = [earliest, latest]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TT.now()&lt;/code&gt; returns the interval during which the call occurred&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TT.after(t)&lt;/code&gt; returns true if &lt;code&gt;t&lt;/code&gt; has definitely passed&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TT.before(t)&lt;/code&gt; returns true if &lt;code&gt;t&lt;/code&gt; has definitely not yet occurred&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TrueTime uses &lt;strong&gt;GPS&lt;/strong&gt; and &lt;strong&gt;atomic clocks&lt;/strong&gt;, each with different failure modes. Each data center has &lt;strong&gt;time master machines&lt;/strong&gt;, and each machine runs a &lt;strong&gt;timeslave daemon&lt;/strong&gt; that polls these masters.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In production, the uncertainty bound ε (epsilon) is typically 1–7 ms, representing half the width of the TTinterval.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;transactions-in-spanner&#34;&gt;Transactions in Spanner&lt;/h2&gt;
&lt;h3 id=&#34;read-write-transactions&#34;&gt;Read-Write Transactions&lt;/h3&gt;
&lt;p&gt;Spanner uses &lt;strong&gt;Two-Phase Locking (2PL)&lt;/strong&gt; and &lt;strong&gt;Two-Phase Commit (2PC)&lt;/strong&gt; for distributed read-write transactions.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The coordinator gathers:
&lt;ul&gt;
&lt;li&gt;Prepared timestamps from non-coordinators&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TTcommit&lt;/code&gt;, the commit time from the client&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;It then chooses a commit timestamp that is:
&lt;ul&gt;
&lt;li&gt;Greater than all prepared timestamps&lt;/li&gt;
&lt;li&gt;Greater than &lt;code&gt;TTcommit.latest&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Greater than any earlier transaction timestamps&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spanner performs a &lt;strong&gt;commit wait&lt;/strong&gt; to ensure this timestamp is safely in the past before finalizing the commit.&lt;/p&gt;
&lt;h3 id=&#34;read-only-transactions&#34;&gt;Read-Only Transactions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;If all required keys reside within a &lt;strong&gt;single Paxos group&lt;/strong&gt;, the leader assigns the &lt;strong&gt;last committed write timestamp&lt;/strong&gt; as the transaction timestamp, minimizing wait time.&lt;/li&gt;
&lt;li&gt;If keys span &lt;strong&gt;multiple Paxos groups&lt;/strong&gt;, the timestamp is set to &lt;code&gt;TT.now().latest&lt;/code&gt;, requiring a small delay until this time safely passes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Read-only transactions can be served from &lt;strong&gt;sufficiently up-to-date replicas&lt;/strong&gt;, allowing for &lt;strong&gt;non-blocking and lock-free reads&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Spanner blends concepts from database and distributed systems research:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;From &lt;strong&gt;databases&lt;/strong&gt;: SQL-like interface, relational schema, transactions&lt;/li&gt;
&lt;li&gt;From &lt;strong&gt;systems&lt;/strong&gt;: Scalability, fault tolerance, sharding, replication, and global distribution&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks to the &lt;strong&gt;TrueTime API&lt;/strong&gt;, Spanner achieves strong guarantees around &lt;strong&gt;external consistency&lt;/strong&gt;, &lt;strong&gt;lock-free read-only transactions&lt;/strong&gt;, and &lt;strong&gt;non-blocking reads in the past&lt;/strong&gt;—demonstrating that precise time semantics are practical and powerful in distributed systems.&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
  </channel>
</rss>
